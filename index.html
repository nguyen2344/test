<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Nguyên đẹp trai + Anh yêu em</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Arial', sans-serif;
    }

    /* Nền 3D để xoay */
    #background-rotation {
      position: absolute;
      width: 100vw;
      height: 100vh;
      perspective: 1000px;
      z-index: 0;
      pointer-events: none;
    }

    #scene {
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      /* Không dùng transition để xoay mượt theo requestAnimationFrame */
    }

    /* Lớp rơi trái tim và chữ */
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      z-index: 1;
      pointer-events: none;
    }

    .falling-text, .heart {
      position: absolute;
      user-select: none;
      pointer-events: none;
      opacity: 0.9;
      animation-timing-function: linear;
      animation-fill-mode: forwards;
    }

    .falling-text {
      font-size: 2rem;
      color: #ff4081;
      font-weight: bold;
      animation-name: fallText;
    }

    .heart {
      font-size: 24px;
      color: #e91e63;
      animation-name: fallHeart;
    }

    @keyframes fallText {
      to {
        transform: translateY(100vh);
        opacity: 0;
      }
    }

    @keyframes fallHeart {
      to {
        transform: translateY(100vh);
        opacity: 0;
      }
    }
  </style>
</head>
<body>

<!-- Nền 3D để xoay -->
<div id="background-rotation">
  <div id="scene"></div>
</div>

<!-- Lớp rơi trái tim và chữ -->
<div id="overlay"></div>

<script>
  const overlay = document.getElementById('overlay');
  const scene = document.getElementById('scene');
  const textList = ["Anh yêu em", "Nguyên đẹp trai"];
  const maxTexts = 300;
  const maxHearts = 200;

  function random(min, max) {
    return Math.random() * (max - min) + min;
  }

  function createFallingText() {
    const text = document.createElement('div');
    text.classList.add('falling-text');
    text.textContent = textList[Math.floor(Math.random() * textList.length)];
    text.style.left = random(0, window.innerWidth - 120) + 'px';
    text.style.top = '-50px';
    text.style.fontSize = random(18, 40) + 'px';
    text.style.animationDuration = random(2, 5) + 's';
    overlay.appendChild(text);
    text.addEventListener('animationend', () => overlay.removeChild(text));
  }

  function createHeart() {
    const heart = document.createElement('div');
    heart.classList.add('heart');
    heart.textContent = "❤️";
    heart.style.left = random(0, window.innerWidth - 30) + 'px';
    heart.style.top = '-30px';
    heart.style.fontSize = random(16, 40) + 'px';
    heart.style.animationDuration = random(2, 4) + 's';
    overlay.appendChild(heart);
    heart.addEventListener('animationend', () => overlay.removeChild(heart));
  }

  // Tạo hiệu ứng rơi liên tục
  setInterval(() => {
    if (document.querySelectorAll('.falling-text').length < maxTexts) createFallingText();
    if (document.querySelectorAll('.heart').length < maxHearts) createHeart();
  }, 80);

  // Xoay nền theo chuột/vuốt tay với quán tính (inertia)
  let rotateX = 0, rotateY = 0;
  let velocityX = 0, velocityY = 0;
  let lastX = 0, lastY = 0;
  let dragging = false;
  const friction = 0.95;  // hệ số giảm tốc

  function animate() {
    if (!dragging) {
      // Giảm vận tốc theo friction
      velocityX *= friction;
      velocityY *= friction;

      // Cập nhật góc xoay theo vận tốc
      rotateX += velocityY;
      rotateY += velocityX;

      // Giới hạn góc xoay X
      rotateX = Math.max(-60, Math.min(60, rotateX));

      // Cập nhật transform
      scene.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;

      // Dừng nếu vận tốc rất nhỏ
      if (Math.abs(velocityX) < 0.01 && Math.abs(velocityY) < 0.01) {
        velocityX = 0;
        velocityY = 0;
      }
    }
    requestAnimationFrame(animate);
  }
  animate();

  // Cập nhật vận tốc khi kéo/vuốt
  function updateVelocity(dx, dy) {
    velocityX = dx * 0.3;
    velocityY = dy * 0.3;
    rotateX -= dy * 0.3;
    rotateY += dx * 0.3;

    rotateX = Math.max(-60, Math.min(60, rotateX));
    scene.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
  }

  // Sự kiện chuột
  document.addEventListener('mousedown', e => {
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });
  document.addEventListener('mouseup', () => dragging = false);
  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    updateVelocity(dx, dy);
    lastX = e.clientX;
    lastY = e.clientY;
  });

  // Sự kiện cảm ứng (mobile)
  document.addEventListener('touchstart', e => {
    dragging = true;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  });
  document.addEventListener('touchend', () => dragging = false);
  document.addEventListener('touchmove', e => {
    if (!dragging) return;
    const dx = e.touches[0].clientX - lastX;
    const dy = e.touches[0].clientY - lastY;
    updateVelocity(dx, dy);
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  });
</script>

</body>
</html>
